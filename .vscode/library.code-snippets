{
    "compress.cpp": {
        "prefix": "compress",
        "body": "template <typename T>\nvector<T> compress(vector<T> &a) {\n    vector<T> p_val = a;\n    sort(all(p_val)); uni(p_val);\n    for (int i = 0; i < (int)a.size(); i++) {\n        a[i] = lower_bound(all(p_val), a[i]) - p_val.begin();\n    }\n    return p_val;\n}\n"
    },
    "segment_tree.cpp": {
        "prefix": "segment_tree",
        "body": "template <typename T>\nclass SegmentTree {\n    inline T f(T x, T y) {\n        return min(x, y);\n    }\n    \n    vector<T> data;\npublic:\n    int n;\n    T init_val;\n    SegmentTree(int size, T ide_ele=(ll)1e18) : init_val(ide_ele) {\n        n = 1;\n        while (n < size) n <<= 1;\n        data.assign(2*n, init_val);\n    }\n    void build(vector<T> &a) {\n        rep(i, (int)a.size()) {\n            data[n+i] = a[i];\n        }\n        for (int i = n-1; i >= 0; i--) {\n            data[i] = f(data[i*2], data[i*2+1]);\n        }\n    }\n    void update(int i, T x) {\n        i += n;\n        data[i] = x;\n        while (i > 1) {\n            i >>= 1;\n            data[i] = f(data[i*2], data[i*2+1]);\n        }\n    }\n    T query(int l, int r) {\n        l += n; r += n;\n        T res = init_val;\n        while (l < r) {\n            if (l & 1) {\n                res = f(res, data[l]);\n                l += 1;\n            }\n            if (r & 1) {\n                res = f(res, data[r-1]);\n            }\n            l >>= 1; r >>= 1;\n        }\n        return res;\n    }\n    const T &operator [] (size_t i) const { return data[i+n]; }\n};\n"
    },
    "cumsum2d.cpp": {
        "prefix": "cumsum2d",
        "body": "class Cumsum2d {\n    int h, w;\n    vvi data;\npublic:\n    Cumsum2d(int h, int w) : h(h), w(w), data(h+1, vi(w+1)) {}\n    void build(vvi &s) {\n        rep(i, h) rep(j, w) {\n            data[i+1][j+1] += data[i][j+1] + data[i+1][j] - data[i][j] + s[i][j];\n        }\n    }\n    int query(int y1, int x1, int y2, int x2) {\n        return data[y2][x2] - data[y1][x2] - data[y2][x1] + data[y1][x1];\n    }\n};\n"
    },
    "dijkstra.cpp": {
        "prefix": "dijkstra",
        "body": "vl dijkstra(const vector<vpi> &g, int s) {\n    vl d(len(g), LINF);\n    priority_queue<pl, vpl, greater<pl>> q;\n    d[s] = 0;\n    q.emplace(make_pair(0, s));\n    while (!q.empty()) {\n        auto [dist, v] = q.top(); q.pop();\n        if (d[v] < dist) continue;\n        for (auto &[nv, cost]: g[v]) {\n            if (d[nv] > d[v] + cost) {\n                d[nv] = d[v] + cost;\n                q.emplace(make_pair(d[nv], nv));\n            }\n        }\n    }\n    return d;\n}\n"
    },
    "modint.cpp": {
        "prefix": "modint",
        "body": "template<int mod>\nstruct ModInt {\n    int x;\n    ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator += (const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator -= (const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator *= (const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator /= (const ModInt &p) {\n        *this *= p.inv();\n        return *this;\n    }\n    ModInt operator - () const { return ModInt(-x); }\n    ModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator == (const ModInt &p) const { return x == p.x; }\n    bool operator != (const ModInt &p) const { return x != p.x; }\n    ModInt inv() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend ostream &operator << (ostream &out, const ModInt &p) {\n        return out << p.x;\n    }\n    friend istream &operator >> (istream &in, ModInt &a) {\n        int64_t t; in >> t;\n        a = ModInt<mod>(t);\n        return in;\n    }\n    static int get_mod() { return mod; }\n};\nusing mint = ModInt<MOD>;\n"
    },
    "union_find.cpp": {
        "prefix": "union_find",
        "body": "struct UnionFind {\n    vi data;\n    UnionFind(int n) : data(n, -1) {}\n    \n    int find(int x) {\n        if (data[x] < 0) return x;\n        return data[x] = find(data[x]);\n    }\n    \n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return;\n        if (data[x] > data[y]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    int size(int x) {\n        return -data[find(x)];\n    }\n};\n"
    },
    "my_template.cpp": {
        "prefix": "my_template",
        "body": "#pragma region my_template\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n \nusing namespace std;\nusing ll = long long;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing ti = tuple<int, int, int>;\nusing tl = tuple<ll, ll, ll>;\nusing vi = vector<int>;\nusing vpi = vector<pi>;\nusing vti = vector<ti>;\nusing vvi = vector<vi>;\nusing usi = unordered_set<int>;\nusing vl = vector<ll>;\nusing vpl = vector<pl>;\nusing vtl = vector<tl>;\nusing vvl = vector<vl>;\nusing usl = unordered_set<ll>;\n \n#define range(i, l, r) for(int i = (int)(l); i < (int)(r); i++)\n#define rrange(i, l, r) for(int i = (int)(r)-1; i >= (int)(l); i--)\n#define rep(i, n) range(i, 0, n)\n#define rrep(i, n) rrange(i, 0, n)\n#define len(a) ((int)(a).size())\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define sum(a) accumulate(all(a), 0)\n#define elif else if\n \nnamespace io {\n    #ifdef LOCAL\n    ofstream dout(\"./dmp.txt\");\n    #else\n    ofstream dout(\"/dev/null\");\n    #endif\n    template<typename T, typename U>\n    istream &operator >> (istream &in, pair<T, U> &a){\n        in >> a.first >> a.second;\n        return in;\n    }\n    template<typename T>\n    istream &operator >> (istream &in, vector<T> &a){\n        for(T &x: a) in >> x;\n        return in;\n    }\n    template<typename T, typename U>\n    ostream &operator << (ostream &out, const pair<T, U> &a){\n        out << a.first << \" \" << a.second;\n        return out;\n    }\n    template<typename T>\n    ostream &operator << (ostream &out, const vector<T> &a) {\n        rep(i, len(a)) out << a[i] << (i == len(a)-1 ? \"\" : \" \");\n        return out;\n    }\n    template<typename T>\n    ostream &operator << (ostream &out, const unordered_set<T> &a) {\n        int i = 0;\n        for (const T &x: a) { out << x << (i == len(a)-1 ? \"\" : \" \"); i++; }\n        return out;\n    }\n    template<typename T>\n    ostream &operator << (ostream &out, const set<T> &a) {\n        int i = 0;\n        for (const T &x: a) { out << x << (i == len(a)-1 ? \"\" : \" \"); i++; }\n        return out;\n    }\n    template<typename T>\n    ostream &operator << (ostream &out, const multiset<T> &a) {\n        int i = 0;\n        for (const T &x: a) { out << x << (i == len(a)-1 ? \"\" : \" \"); i++; }\n        return out;\n    }\n    inline void print() { cout << \"\\n\"; }\n    template <typename T, typename ...U>\n    inline void print(const T &t, const U &...u) {\n        cout << t;\n        if (sizeof...(u)) cout << \" \";\n        print(u...);\n    }\n    inline void dmp() { dout << endl; }\n    template <typename T, typename ...U>\n    inline void dmp(const T &t, const U &...u) {\n        dout << t;\n        if (sizeof...(u)) dout << \" \";\n        dmp(u...);\n    }\n}\nusing namespace io;\n \ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return 1; } return 0; }\nvoid solve();\n\nconstexpr int INF = 1e9;\nconstexpr ll LINF = 1e18;\nconstexpr int MOD = 1e9+7;\n//constexpr int MOD = 998244353;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //cout << fixed << setprecision(15);\n    solve();\n    return 0;\n}\n#pragma endregion\n\nvoid solve() {\n    \n}\n"
    },
    "binary_indexed_tree.cpp": {
        "prefix": "binary_indexed_tree",
        "body": "template<typename T>\nclass BIT {\n    int N;\n    vector<T> data;\npublic:\n    BIT(int n) : N(n+1), data(N) {}\n    T sum(int r) {\n        T res = 0;\n        for (int i = r; i > 0; i -= i & -i) {\n            res += data[i];\n        }\n        return res;\n    }\n    T sum() { return sum(N-1); }\n    T sum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n    void add(int idx, T x = 1) {\n        for(int i = idx+1; i < N; i += i & -i) {\n            data[i] += x;\n        }\n    }\n    int lower_bound(T val) {\n        int x = 0, r = 1;\n        while (r < N) r = r << 1;\n        for (int k = r; k > 0; k = k >> 1) {\n            if (x + k < N && data[x + k] < val) {\n                val -= data[x + k];\n                x += k;\n            }\n        }\n        return x;\n    }\n};\n"
    }
}